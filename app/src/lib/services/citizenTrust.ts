import "server-only"

import { citizenCategory, SocialTrustPlatform } from "@prisma/client"

import {
  lookupOpenRankScore,
  OpenRankPlatform,
} from "@/lib/integrations/openrank"
import {
  fetchPassportScore,
  PassportScoreResult,
} from "@/lib/integrations/humanPassport"

export type TrustBand = "NONE" | "BRONZE" | "SILVER" | "GOLD" | "PLATINUM"

export interface WalletTrustScore {
  address: string
  score: number | null
  band: TrustBand
  source: PassportScoreResult
}

export interface SocialTrustScore {
  platform: SocialTrustPlatform
  identifier: string
  score: number | null
  band: TrustBand
  source:
    | OpenRankLookupResult
    | MissingOpenRankScore
}

type OpenRankLookupResult = Awaited<ReturnType<typeof lookupOpenRankScore>>
type MissingOpenRankScore = {
  score: null
  source: "missing"
  identifier: string
  platform: OpenRankPlatform
}

export interface TrustEvaluationResult {
  seasonId: string
  userId: string
  citizenType: citizenCategory
  walletScores: WalletTrustScore[]
  socialScores: SocialTrustScore[]
  hasPlatinum: boolean
  hasGold: boolean
  decision: "ALLOW" | "NEEDS_VERIFICATION" | "BLOCKED"
}

export interface EvaluateTrustArgs {
  seasonId: string
  userId: string
  citizenType: citizenCategory
  wallets: string[]
  socials: Array<{ platform: SocialTrustPlatform; identifier: string }>
  citizenSeasonId?: string | null
}

const WALLET_THRESHOLDS = {
  BRONZE: 15,
  SILVER: 25,
  GOLD: 50,
  PLATINUM: 75,
} as const

/**
 * Pre-calculated score thresholds for OpenRank percentile bands.
 * Generated by: pnpm tsx src/scripts/calculate-openrank-thresholds.ts
 * Season: 9
 * Generated at: 2026-01-09
 *
 * These thresholds represent the score values at each percentile boundary:
 * - SILVER: >= 50th percentile
 * - GOLD: >= 70th percentile
 * - PLATINUM: >= 90th percentile
 */
const OPENRANK_SCORE_THRESHOLDS: Record<
  SocialTrustPlatform,
  { SILVER: number; GOLD: number; PLATINUM: number }
> = {
  GITHUB: {
    SILVER: 0.473168,
    GOLD: 0.539313,
    PLATINUM: 0.643298,
  },
  FARCASTER: {
    SILVER: 0.7598354104412217,
    GOLD: 0.7873598245163276,
    PLATINUM: 0.8281287218131229,
  },
  X: {
    SILVER: 0.4878555229291473,
    GOLD: 0.5508053069954423,
    PLATINUM: 0.6752094621216629,
  },
}

const WALLET_BATCH_SIZE = 5
const SOCIAL_BATCH_SIZE = 5

export async function evaluateTrustScores({
  seasonId,
  userId,
  citizenType,
  wallets,
  socials,
}: EvaluateTrustArgs): Promise<TrustEvaluationResult> {
  const walletScores = await evaluateWalletScores(wallets)
  const socialScores = await evaluateSocialScores({ seasonId, socials })

  const isBlocked = walletScores.some((wallet) => wallet.source.status === "blocked")

  if (isBlocked) {
    return {
      seasonId,
      userId,
      citizenType,
      walletScores,
      socialScores,
      hasPlatinum: false,
      hasGold: false,
      decision: "BLOCKED",
    }
  }

  const bands = [...walletScores, ...socialScores].map((score) => score.band)

  const platinumCount = bands.filter((band) => band === "PLATINUM").length
  const goldOrHigherCount = bands.filter((band) => band === "PLATINUM" || band === "GOLD").length

  const hasPlatinum = platinumCount > 0
  const hasGold = goldOrHigherCount > 0

  const meetsAutoPass = hasPlatinum && goldOrHigherCount >= 2

  return {
    seasonId,
    userId,
    citizenType,
    walletScores,
    socialScores,
    hasPlatinum,
    hasGold,
    decision: meetsAutoPass ? "ALLOW" : "NEEDS_VERIFICATION",
  }
}

export function serializeTrustScores(result: TrustEvaluationResult) {
  const socialRaw = result.socialScores.map((social) => ({
    platform: social.platform,
    identifier: social.identifier,
    score: social.score,
    band: social.band,
    source: social.source?.source ?? "missing",
    loadedAt: extractLoadedAt(social.source),
  }))

  const passportRaw = result.walletScores.map((wallet) => ({
    address: wallet.address,
    score: wallet.score,
    band: wallet.band,
    status: wallet.source.status,
    error: wallet.source.error ?? null,
  }))

  return {
    socialRaw,
    passportRaw,
  }
}

async function evaluateWalletScores(wallets: string[]): Promise<WalletTrustScore[]> {
  if (wallets.length === 0) {
    return []
  }

  const normalizedWallets = wallets.map((address) => address.toLowerCase())
  const uniqueWallets = Array.from(new Set(normalizedWallets))

  const uniqueResults = await mapInBatches(
    uniqueWallets,
    WALLET_BATCH_SIZE,
    async (address) => {
      const passportScore = await fetchPassportScore({ address })
      const band = mapWalletBand(passportScore)
      return {
        address,
        score: passportScore.score,
        band,
        source: passportScore,
      }
    },
  )

  const walletMap = new Map(uniqueWallets.map((address, index) => [address, uniqueResults[index]]))

  return normalizedWallets.map((address) => {
    const score = walletMap.get(address)
    if (!score) {
      throw new Error(`Missing passport score for wallet ${address}`)
    }
    return score
  })
}

async function evaluateSocialScores({
  seasonId,
  socials,
}: {
  seasonId: string
  socials: EvaluateTrustArgs["socials"]
}): Promise<SocialTrustScore[]> {
  if (socials.length === 0) {
    return []
  }

  const results = await mapInBatches(
    socials,
    SOCIAL_BATCH_SIZE,
    async ({ platform, identifier }) => {
      const lookup = await lookupOpenRankScore({
        seasonId,
        platform: platform as OpenRankPlatform,
        identifier,
      })

      // Map score to band using pre-calculated percentile thresholds
      const band = mapOpenRankScoreToBand(platform, lookup.score)

      return {
        platform,
        identifier,
        score: lookup.score,
        band,
        source: lookup,
      }
    },
  )

  return results
}

function mapWalletBand(result: PassportScoreResult): TrustBand {
  switch (result.status) {
    case "blocked":
      return "NONE"
    case "insufficient":
      return "NONE"
    case "error":
      return "NONE"
    case "ok":
    default:
      break
  }

  if (result.score === null) {
    return "NONE"
  }

  if (result.score >= WALLET_THRESHOLDS.PLATINUM) return "PLATINUM"
  if (result.score >= WALLET_THRESHOLDS.GOLD) return "GOLD"
  if (result.score >= WALLET_THRESHOLDS.SILVER) return "SILVER"
  if (result.score >= WALLET_THRESHOLDS.BRONZE) return "BRONZE"
  return "NONE"
}


function extractLoadedAt(
  source: OpenRankLookupResult | MissingOpenRankScore | undefined,
) {
  if (!source) {
    return null
  }

  if ("loadedAt" in source) {
    return source.loadedAt ?? null
  }

  return null
}

async function mapInBatches<T, R>(
  items: readonly T[],
  batchSize: number,
  mapper: (item: T, index: number) => Promise<R>,
): Promise<R[]> {
  if (items.length === 0) {
    return []
  }

  const size = Math.max(1, batchSize)
  const results: R[] = []

  for (let start = 0; start < items.length; start += size) {
    const batch = items.slice(start, start + size)
    const mapped = await Promise.all(
      batch.map((item, index) => mapper(item, start + index)),
    )
    results.push(...mapped)
  }

  return results
}

/**
 * Maps an OpenRank score to a trust band using pre-calculated percentile thresholds.
 * Thresholds are platform-specific since each platform has different score distributions.
 */
function mapOpenRankScoreToBand(
  platform: SocialTrustPlatform,
  score: number | null,
): TrustBand {
  if (score === null) {
    return "NONE"
  }

  const thresholds = OPENRANK_SCORE_THRESHOLDS[platform]
  if (!thresholds) {
    return "NONE"
  }

  if (score >= thresholds.PLATINUM) return "PLATINUM"
  if (score >= thresholds.GOLD) return "GOLD"
  if (score >= thresholds.SILVER) return "SILVER"
  // Any score > 0 is at least Bronze (in the dataset)
  if (score > 0) return "BRONZE"
  return "NONE"
}
